<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>La Polo du Myth - Simulateur de Crash et High Score</title>
    <!-- Chargement de Tailwind CSS pour les classes utilitaires -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- STYLES CSS INT√âGR√âS (contenu de style.css) -->
    <style>
        /* Custom CSS for a racing game feel */
        @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@600;700&display=swap');
        
        body {
            background-color: #1a1a2e; /* Deep purple background */
            color: #ffffff;
            font-family: 'Chakra Petch', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            width: 100%;
            max-width: 768px;
            background-color: #0f0f1c; /* Darker inner panel */
            border: 4px solid #e94560; /* Racing red border */
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(233, 69, 96, 0.4);
            text-align: center;
        }

        canvas {
            display: block;
            width: 100%; 
            height: auto;
            max-height: 400px;
            background-color: #272744; 
            border-radius: 10px;
            margin: 20px auto;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
        }

        /* Button Styles */
        #start-button, .action-button, .auth-button {
            transition: all 0.2s ease-in-out;
            font-weight: 700;
            padding: 12px 30px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
        }
        
        #start-button {
            background-color: #53bf9d; /* Teal/Green for GO */
            color: #1a1a2e;
            font-size: 1.25rem;
            box-shadow: 0 4px #429a7e;
        }
        #start-button:hover:not(:disabled) {
            background-color: #63d1ac;
            transform: translateY(-2px);
            box-shadow: 0 6px #429a7e;
        }
        #start-button:active:not(:disabled) {
            transform: translateY(2px);
            box-shadow: 0 2px #429a7e;
        }

        .action-button {
            background-color: #4a5568; /* Gray for actions */
            color: #ffffff;
            box-shadow: 0 3px #3c4452;
        }

        .auth-button { /* Kept for styling, but less used */
            background-color: #e94560; /* Red for auth */
            color: #ffffff;
            box-shadow: 0 3px #cc3a52;
        }

        .disabled-button {
            opacity: 0.6;
            cursor: not-allowed;
            background-color: #aaaaaa !important;
            box-shadow: 0 4px #777777 !important;
        }

        .result-text {
            min-height: 60px;
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #0f0f1c;
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 10px 30px rgba(233, 69, 96, 0.6);
        }

        /* Responsive adjustments for mobile devices (< 640px) */
        @media (max-width: 640px) {
            .container {
                padding: 20px 10px; 
                margin: 10px; 
                border-width: 2px; 
            }
            #start-button, .action-button, .auth-button {
                font-size: 1rem;
                padding: 10px 20px;
            }
        }
    </style>
</head>
<body>

<div class="container">
    <div class="flex justify-between items-center mb-6">
        <!-- MODIFIED: auth-status now includes a span for the name and a button to edit -->
        <div id="auth-status" class="text-sm font-medium text-gray-400 text-left flex items-center">
            <span>Chargement...</span>
            <button id="edit-username-button" class="ml-2 text-pink-400 hover:text-pink-300 text-xs font-bold py-1 px-2 rounded-md border border-pink-400 hidden" onclick="showEditUsernameModal()">Modifier</button>
        </div>
        <div>
            <!-- Removed the old "Connexion / Inscription" button -->
        </div>
    </div>
    
    <h1 class="text-3xl font-bold mb-2 text-pink-400">La Polo du Myth</h1>
    <div id="high-score" class="text-xl font-extrabold mb-4 text-yellow-300">
        Meilleur Score: 0 tours
    </div>
    <p class="mb-6 text-gray-300">Myth survivra-t-il dans sa Polo ? La course continue jusqu'√† ce qu'il s'√©crase !</p>

    <div class="flex flex-col md:flex-row justify-center items-center gap-4 mb-6">
        <button id="start-button" onclick="runSimulation()">
            D√©marrer la Course !
        </button>
        <p id="current-status" class="text-xl font-semibold text-yellow-300">Pr√™t</p>
    </div>

    <canvas id="race-track" width="600" height="300"></canvas>
    
    <div id="results" class="result-text mt-6 text-2xl font-extrabold">
        <!-- Les r√©sultats seront affich√©s ici -->
    </div>

    <!-- SECTION CLASSEMENT GLOBAL -->
    <div class="mt-8">
        <h2 class="text-2xl font-bold mb-4 text-yellow-400">üèÜ Top 3 Mythes</h2>
        <div id="leaderboard" class="bg-gray-800 p-4 rounded-lg shadow-inner">
            <p class="text-gray-400">Chargement du classement...</p>
        </div>
    </div>
</div>

<!-- Removed the old Authentication Modal -->

<!-- NEW: Edit Username Modal -->
<div id="edit-username-modal" class="modal">
    <div class="modal-content">
        <h2 class="text-2xl font-bold mb-4 text-pink-400">Choisir un Nom d'Utilisateur</h2>
        <form id="username-form" onsubmit="handleUsernameEditSubmit(event)">
            <input type="text" id="new-username-input" placeholder="Votre Nom d'Utilisateur" required minlength="3" maxlength="20"
                   class="w-full p-3 mb-3 bg-gray-700 text-white border border-gray-600 rounded-lg focus:ring-pink-500 focus:border-pink-500">
            <p id="username-error" class="text-red-400 mb-4 h-6"></p>
            <button type="submit" class="action-button w-full mb-3">
                Sauvegarder
            </button>
            <button type="button" class="auth-button w-full" onclick="document.getElementById('edit-username-modal').style.display='none'">
                Annuler
            </button>
        </form>
    </div>
</div>

<!-- LOGIQUE JAVASCRIPT INT√âGR√âE (contenu de script.js) -->
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged, updateProfile } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js"; // Removed signInWithCustomToken, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut
    import { getFirestore, doc, setDoc, getDoc, collection, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- Firebase Setup (MANDATORY) ---
    // ‚ö†Ô∏è ATTENTION : SI VOUS EX√âCUTEZ CE CODE HORS DU CANVAS (ex: sur GitHub), 
    // VEUILLEZ REMPLACER LES CHA√éNES VIDES ("") CI-DESSOUS PAR VOTRE CONFIGURATION FIREBASE R√âELLE 
    // POUR ACTIVER LA SAUVEGARDE ET LE CLASSEMENT GLOBAL.

    // 1. D√âFINISSEZ VOTRE CONFIGURATION ICI :
    const GITHUB_FIREBASE_CONFIG = {
        apiKey: "AIzaSyBsWugLEz2bu5xjbR5VtYXMr7cUhD6ycEE", // CL√â REQUISE pour la sauvegarde
        authDomain: "lapolo-5351b.firebaseapp.com",
        projectId: "lapolo-5351b", 
        storageBucket: "lapolo-5351b.firebasestorage.app",
        messagingSenderId: "1031146720807",
        appId: "1:1031146720807:web:6324e1b371bbb953410802"
    };
    const GITHUB_APP_ID = GITHUB_FIREBASE_CONFIG.projectId || 'local-github-app';


    // 2. LOGIQUE DE S√âLECTION DE LA CONFIGURATION :
    // V√©rifie si nous sommes dans l'environnement Canvas (o√π les variables sont inject√©es)
    const isCanvas = typeof __app_id !== 'undefined';
    
    const appId = isCanvas 
        ? __app_id 
        : GITHUB_APP_ID;
    const firebaseConfig = isCanvas 
        ? JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}')
        : GITHUB_FIREBASE_CONFIG;
    // Le token d'authentification personnalis√© n'est PAS disponible en dehors du Canvas.
    // initialAuthToken is no longer used, as we're solely relying on anonymous sign-in now.
    const initialAuthToken = null; 
    
    // MODIFIED: This condition now correctly identifies an *actual* placeholder or missing key.
    // Your provided API key is now treated as a valid configuration.
    const isGithubPlaceholder = !isCanvas && (!firebaseConfig.apiKey || firebaseConfig.apiKey === "YOUR_API_KEY_GOES_HERE");
    
    // --------------------------------------------------------------------------------


    let app;
    let db;
    let auth;
    let userId = null;
    let currentHighScore = 0;
    let currentUsername = null; 
    
    // Game variables
    const CRASH_CHANCE = 0.20; 
    let isRacing = false;
    let lapCount = 0;
    let angle = 0; 
    let anglePerFrame = 0.05; 
    let crashLapNumber = -1; 
    let animationFrameId;

    // Canvas variables
    const canvas = document.getElementById('race-track');
    const ctx = canvas.getContext('2d');
    const statusText = document.getElementById('current-status');
    const resultsDiv = document.getElementById('results');
    const startButton = document.getElementById('start-button');
    const authStatusDiv = document.getElementById('auth-status');
    // Removed authToggleButton
    const highScoreDiv = document.getElementById('high-score');
    const leaderboardDiv = document.getElementById('leaderboard'); 
    const editUsernameButton = document.getElementById('edit-username-button'); 

    let centerX, centerY, radiusX, radiusY;

    // Removed Auth Modal Elements

    // NEW: Edit Username Modal Elements
    const editUsernameModal = document.getElementById('edit-username-modal');
    const newUsernameInput = document.getElementById('new-username-input');
    const usernameError = document.getElementById('username-error');


    // --- Firestore High Score Management (Private Data) ---

    function getHighScoreDocRef() {
        if (!db || !userId) return null;
        // Private data path: /artifacts/{appId}/users/{userId}/game_data/high_score
        return doc(db, 'artifacts', appId, 'users', userId, 'game_data', 'high_score');
    }

    async function fetchHighScore() {
        if (isGithubPlaceholder || !userId || !db) return 0;
        try {
            const docRef = getHighScoreDocRef();
            const docSnap = await getDoc(docRef);

            if (docSnap.exists()) {
                currentHighScore = docSnap.data().maxLaps || 0;
            } else {
                currentHighScore = 0;
            }
            highScoreDiv.textContent = `Meilleur Score: ${currentHighScore} tours`;
            return currentHighScore;
        } catch (error) {
            console.error("Erreur lors de la r√©cup√©ration du score:", error);
            return 0;
        }
    }

    async function updateHighScore(newScore) {
        if (isGithubPlaceholder || !userId || !db) {
             console.warn("Sauvegarde des scores ignor√©e : Firebase non configur√© ou mode local.");
             currentHighScore = Math.max(currentHighScore, newScore); // Update local best score for the session
             highScoreDiv.textContent = `Meilleur Score: ${currentHighScore} tours (Local)`;
             return;
        }
        
        if (newScore > currentHighScore) {
            try {
                const docRef = getHighScoreDocRef();
                await setDoc(docRef, { maxLaps: newScore }, { merge: true });
                
                currentHighScore = newScore;
                highScoreDiv.textContent = `Meilleur Score: ${currentHighScore} tours`;
                console.log("Meilleur score mis √† jour:", newScore);

                // MODIFIED: Update the global score if *any* user (anonymous or not) has a username set
                if (auth.currentUser && currentUsername) {
                     updateGlobalScore(newScore, currentUsername);
                }

            } catch (error) {
                console.error("Erreur lors de la mise √† jour du score:", error);
            }
        }
    }

    // --- Global Leaderboard Management (Public Data) ---

    async function updateGlobalScore(newScore, username) {
        // MODIFIED: Simplified check - now only needs db, current user, and provided username
        if (isGithubPlaceholder || !db || !auth.currentUser || !username) return; 

        try {
            // Public data path: /artifacts/{appId}/public/data/global_high_scores/{userId}
            const globalDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'global_high_scores', auth.currentUser.uid);
            
            const docSnap = await getDoc(globalDocRef);
            const existingGlobalScore = docSnap.exists() ? docSnap.data().maxLaps : 0;

            if (newScore > existingGlobalScore) {
                await setDoc(globalDocRef, {
                    userId: auth.currentUser.uid,
                    username: username,
                    maxLaps: newScore,
                    updatedAt: new Date().toISOString()
                });
                console.log("Score global mis √† jour:", newScore);
                fetchGlobalLeaderboard(); 
            }

        } catch (error) {
            console.error("Erreur lors de la mise √† jour du score global:", error);
        }
    }
    
    async function fetchGlobalLeaderboard() {
        if (isGithubPlaceholder || !db) {
            leaderboardDiv.innerHTML = '<p class="text-yellow-500">Le classement est d√©sactiv√©. Configurez Firebase pour le voir.</p>';
            return;
        }

        try {
            const leaderboardCollectionRef = collection(db, 'artifacts', appId, 'public', 'data', 'global_high_scores');
            
            // Query: order by maxLaps descending, limit to 10 (or adjust as desired)
            const q = query(leaderboardCollectionRef, orderBy('maxLaps', 'desc'), limit(10));
            const querySnapshot = await getDocs(q);

            let html = '';
            if (querySnapshot.empty) {
                html = '<p class="text-gray-400">Aucun score enregistr√©. Soyez le premier !</p>';
            } else {
                // FIX: Changed from forEach to a traditional for loop to ensure 'i' is always a number
                for (let i = 0; i < querySnapshot.docs.length; i++) {
                    const docSnap = querySnapshot.docs[i]; // Get the document snapshot
                    const data = docSnap.data();
                    
                    // The 'i' from the for loop is guaranteed to be a sequential number (0, 1, 2...)
                    const rank = i + 1; // Calculate rank from this reliable index

                    // Debugging line (can be removed after verification)
                    console.log(`DEBUG: Leaderboard entry - loop index: ${i}, calculated rank: ${rank}, username: ${data.username || 'Unknown'}, score: ${data.maxLaps}`);

                    // --- Start Medal and Rank Display Logic ---
                    let displayRankString;
                    let medalColorClass;

                    if (rank === 1) {
                        displayRankString = 'ü•á #1'; // Gold medal for the best
                        medalColorClass = 'text-yellow-300';
                    } else if (rank === 2) {
                        displayRankString = 'ü•à #2'; // Silver medal for the second best
                        medalColorClass = 'text-gray-300'; // Tailwind gray-300 for silver look
                    } else if (rank === 3) {
                        displayRankString = 'ü•â #3'; // Bronze medal for the third best
                        medalColorClass = 'text-amber-500'; // Tailwind amber for bronze look
                    } else {
                        // For ranks beyond 3, just display the number
                        displayRankString = `#${rank}`;
                        medalColorClass = 'text-gray-400'; // Default color for other ranks
                    }
                    // --- End Medal and Rank Display Logic ---
                    
                    // Highlight the current user if they are on the leaderboard
                    const highlightClass = (data.userId === userId && auth.currentUser) ? 'bg-pink-800/50' : 'hover:bg-gray-700/50';

                    html += `
                        <div class="flex justify-between items-center p-3 my-1 rounded-lg ${highlightClass}">
                            <span class="text-xl font-extrabold ${medalColorClass}">${displayRankString}</span>
                            <span class="text-lg font-semibold">${data.username || 'Utilisateur inconnu'}</span>
                            <span class="text-lg font-bold text-teal-400">${data.maxLaps} tours</span>
                        </div>
                    `;
                } // End of for loop
            }
            leaderboardDiv.innerHTML = html;

        } catch (error) {
            console.error("Erreur lors de la r√©cup√©ration du classement:", error);
            leaderboardDiv.innerHTML = '<p class="text-red-400">Erreur lors du chargement du classement.</p>';
        }
    }


    // --- Firestore Profile Management ---

    async function fetchUserProfile(uid) {
        if (isGithubPlaceholder || !db) return null;
        try {
            const profileDocRef = doc(db, 'artifacts', appId, 'users', uid, 'profile', 'data');
            const docSnap = await getDoc(profileDocRef);
            return docSnap.exists() ? docSnap.data().username : null;
        } catch (error) {
            console.error("Erreur lors de la r√©cup√©ration du profil:", error);
            return null;
        }
    }

    async function saveUserProfile(uid, username) {
        if (isGithubPlaceholder || !db) return;
        try {
            const profileDocRef = doc(db, 'artifacts', appId, 'users', uid, 'profile', 'data');
            await setDoc(profileDocRef, { username: username, createdAt: new Date().toISOString() }, { merge: true }); // Merge true to not overwrite other fields
        } catch (error) {
            console.error("Erreur lors de la sauvegarde du profil:", error);
        }
    }


    // --- Authentication Logic ---

    function updateAuthUI(user) {
        if (isGithubPlaceholder) {
            authStatusDiv.querySelector('span').textContent = 'Mode Local (Scores non sauvegard√©s).';
            editUsernameButton.style.display = 'none'; // Hide edit button in placeholder mode
            highScoreDiv.textContent = `Meilleur Score: ${currentHighScore} tours (Local)`;
            return;
        }

        if (user) {
            userId = user.uid;
            
            fetchUserProfile(user.uid).then(username => {
                currentUsername = username; // Update currentUsername from profile
                
                authStatusDiv.querySelector('span').innerHTML = `Connect√© comme : <span class="text-pink-400">${username || 'Anonyme'}</span>`;
                editUsernameButton.style.display = 'inline-block'; // Always show edit button for anonymous users
            });
            
            // 2. No main auth toggle anymore, only for editing username
            
            // 3. Load game data
            fetchHighScore(); 
            fetchGlobalLeaderboard(); 
        } else {
            // User is not logged in, but anonymous auto-signin should prevent this state
            userId = null;
            currentUsername = null;
            currentHighScore = 0;
            authStatusDiv.querySelector('span').textContent = 'Non connect√©. Connectez-vous pour sauvegarder votre score.';
            highScoreDiv.textContent = 'Meilleur Score: 0 tours';
            editUsernameButton.style.display = 'none'; // Hide edit button if not logged in
        }
    }

    async function initializeFirebase() {
        if (isGithubPlaceholder) {
            console.warn("‚ö†Ô∏è Mode GitHub sans configuration Firebase : La sauvegarde des scores et l'authentification sont d√©sactiv√©es.");
            updateAuthUI(null); 
            return;
        }
        
        // Ensure configuration is valid before attempting connection
        if (Object.keys(firebaseConfig).length === 0 || !firebaseConfig.apiKey) {
            console.error("Erreur: Configuration Firebase incompl√®te.");
            authStatusDiv.querySelector('span').textContent = 'ERREUR FIREBASE. Configuration manquante. V√©rifiez la console.';
            return;
        }

        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app); 

            // Listen for auth state changes
            onAuthStateChanged(auth, async (user) => {
                if (!user) {
                    // If no user is logged in (e.g., after a manual clear storage), sign in anonymously immediately
                    await signInAnonymously(auth);
                } else {
                    updateAuthUI(user);
                }
            });

            // Ensure an anonymous user is signed in right away if not already
            if (!auth.currentUser) {
                 await signInAnonymously(auth);
            }
        } catch (error) {
            console.error("Erreur fatale lors de l'initialisation de Firebase:", error);
            authStatusDiv.querySelector('span').textContent = 'ERREUR FIREBASE FATALE. V√©rifiez la console et votre configuration.';
            db = null;
            auth = null;
        }
    }

    // Removed window.showAuthModal, window.toggleAuthMode, window.handleAuthSubmit

    // window.signOutUser is no longer directly exposed via a button, but could be used internally if needed.
    // For this anonymous-first flow, users don't "sign out" in the traditional sense.

    // NEW: Functions for Edit Username Modal
    window.showEditUsernameModal = () => {
        if (isGithubPlaceholder || !auth.currentUser) return;
        newUsernameInput.value = currentUsername || ''; // Pre-fill with current name if available
        usernameError.textContent = '';
        editUsernameModal.style.display = 'flex';
    };

    window.handleUsernameEditSubmit = async (event) => {
        event.preventDefault();
        const newUsername = newUsernameInput.value.trim();
        usernameError.textContent = '';

        if (!newUsername || newUsername.length < 3 || newUsername.length > 20) {
            usernameError.textContent = 'Le nom d\'utilisateur doit contenir entre 3 et 20 caract√®res.';
            return;
        }
        if (newUsername === currentUsername) { // No change
            editUsernameModal.style.display = 'none';
            return;
        }

        try {
            if (auth.currentUser && auth.currentUser.uid) {
                await saveUserProfile(auth.currentUser.uid, newUsername);
                currentUsername = newUsername; // Update local state
                updateAuthUI(auth.currentUser); // Refresh UI to show new name
                fetchGlobalLeaderboard(); // Refresh leaderboard with new name (uses currentUsername)
                editUsernameModal.style.display = 'none';
                console.log("Nom d'utilisateur mis √† jour:", newUsername);
            }
        } catch (error) {
            console.error("Erreur lors de la mise √† jour du nom d'utilisateur:", error);
            usernameError.textContent = 'Erreur lors de la sauvegarde du nom. Veuillez r√©essayer.';
        }
    };


    // --- Drawing Functions ---

    function resizeCanvas() {
        const parent = canvas.parentElement;
        const desiredWidth = parent.clientWidth;
        const desiredHeight = desiredWidth / 2; 

        canvas.width = desiredWidth > 600 ? 600 : desiredWidth;
        canvas.height = desiredHeight > 300 ? 300 : desiredHeight;

        centerX = canvas.width / 2;
        centerY = canvas.height / 2;
        radiusX = centerX * 0.7; 
        radiusY = centerY * 0.7; 
        
        if (!isRacing) {
            drawTrack(false);
        }
    }

    window.addEventListener('resize', resizeCanvas);

    function drawTrack(isCrashed = false) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 1. Draw Racing Green Grass (infield)
        ctx.fillStyle = '#272744';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 2. Draw Outer Track Boundary (White Line)
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 15;
        ctx.ellipse(centerX, centerY, radiusX + 15, radiusY + 15, 0, 0, 2 * Math.PI);
        ctx.stroke();

        // 3. Draw Track Surface (Asphalt)
        ctx.beginPath();
        ctx.fillStyle = '#3c4048'; // Dark asphalt gray
        ctx.ellipse(centerX, centerY, radiusX + 5, radiusY + 5, 0, 0, 2 * Math.PI);
        ctx.fill();

        // 4. Draw Inner Track Boundary (White Line)
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 10;
        
        const innerRadiusX = Math.max(1, radiusX - 10);
        const innerRadiusY = Math.max(1, radiusY - 10);
        
        ctx.ellipse(centerX, centerY, innerRadiusX, innerRadiusY, 0, 0, 2 * Math.PI);
        ctx.stroke();

        // 5. Draw Start/Finish Line (Red/White stripes)
        const startX = centerX + radiusX;
        const startY = centerY;
        
        ctx.lineWidth = 5;
        ctx.strokeStyle = 'white';
        ctx.beginPath();
        ctx.moveTo(startX, startY - 15);
        ctx.lineTo(startX, startY + 15);
        ctx.stroke();
        
        ctx.strokeStyle = '#e94560'; // Red
        ctx.beginPath();
        ctx.moveTo(startX, startY - 10);
        ctx.lineTo(startX, startY + 10);
        ctx.stroke();

        // 6. Draw Car
        let currentAngle = angle;
        
        // Calculate car position on the ellipse
        const carX = centerX + radiusX * Math.cos(currentAngle);
        const carY = centerY + radiusY * Math.sin(currentAngle);

        // Calculate car rotation (tangent to the ellipse path)
        const dx = -radiusX * Math.sin(currentAngle);
        const dy = radiusY * Math.cos(currentAngle);
        const rotation = Math.atan2(dy, dx);

        ctx.save();
        ctx.translate(carX, carY);
        ctx.rotate(rotation);

        if (isCrashed) {
            // Apply crash transformation
            const crashJitterX = Math.random() * 8 - 4;
            const crashJitterY = Math.random() * 8 - 4;
            ctx.rotate(Math.PI / 8); 
            ctx.translate(crashJitterX, crashJitterY);
        }

        // Car Body (The "Polo") - Set to Dark Green or Red if crashed
        ctx.fillStyle = isCrashed ? '#ff0000' : '#1e4620';
        ctx.fillRect(-15, -8, 30, 16);
        
        // Cabin
        ctx.fillStyle = '#222222';
        ctx.fillRect(-5, -6, 10, 8); 

        // Headlights (only if not crashed)
        if (!isCrashed) {
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(12, -6, 3, 2);
            ctx.fillRect(12, 4, 3, 2);
        }

        // Wheels
        ctx.fillStyle = '#333333';
        ctx.beginPath();
        ctx.arc(-10, -8, 4, 0, 2 * Math.PI); ctx.fill();
        ctx.beginPath();
        ctx.arc(-10, 8, 4, 0, 2 * Math.PI); ctx.fill();
        ctx.beginPath();
        ctx.arc(10, -8, 4, 0, 2 * Math.PI); ctx.fill();
        ctx.beginPath();
        ctx.arc(10, 8, 4, 0, 2 * Math.PI); ctx.fill();

        ctx.restore();

        // Draw Crash Smoke/Particles if crashed
        if (isCrashed) {
            for(let i = 0; i < 20; i++) {
                const smokeX = carX + (Math.random() - 0.5) * 40;
                const smokeY = carY + (Math.random() - 0.5) * 40;
                const smokeRadius = Math.random() * 10 + 5;
                ctx.fillStyle = `rgba(150, 150, 150, ${Math.random() * 0.6})`;
                ctx.beginPath();
                ctx.arc(smokeX, smokeY, smokeRadius, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
    }

    // --- Simulation Core Logic ---

    function gameLoop() {
        if (!isRacing) {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            return;
        }

        angle += anglePerFrame;

        // Check for lap completion
        if (angle >= (lapCount + 1) * 2 * Math.PI) {
            
            lapCount++; // Completed the lap
            statusText.textContent = `Tour ${lapCount}`; 

            // Dynamic Crash Check
            if (Math.random() < CRASH_CHANCE) {
                crashLapNumber = lapCount;
                endSimulation(true);
                return;
            }
        }
        
        drawTrack();
        
        animationFrameId = requestAnimationFrame(gameLoop);
    };

    window.runSimulation = () => {
        if (isRacing) return;

        // Basic check for auth readiness (even in placeholder mode, we need a userId mock)
        if (!userId) { 
            resultsDiv.classList.add('text-red-400');
            resultsDiv.innerHTML = `‚ö†Ô∏è Veuillez patienter, l'application est en cours d'initialisation...`;
            return;
        }

        // 1. Reset State
        isRacing = true;
        lapCount = 0;
        angle = 0;
        crashLapNumber = -1; 
        resultsDiv.innerHTML = '';
        
        // 2. Update UI
        startButton.disabled = true;
        startButton.classList.add('disabled-button');
        startButton.textContent = 'COURSE EN COURS...';
        statusText.textContent = `Tour 1`; 

        // 3. Start Loop
        animationFrameId = requestAnimationFrame(gameLoop);
    };

    function endSimulation(crashed) {
        isRacing = false;
        
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }

        if (crashed) {
            drawTrack(true); 
            resultsDiv.classList.remove('text-green-400');
            resultsDiv.classList.add('text-red-400');
            resultsDiv.innerHTML = `üö® **CRASH !** Myth s'est √©cras√© au Tour ${crashLapNumber} ! üíî`;

            // High Score Check and Update (Handles local/remote logic internally)
            updateHighScore(crashLapNumber); 
        } 
        
        // Reset button UI after a delay
        setTimeout(() => {
            startButton.disabled = false;
            startButton.classList.remove('disabled-button');
            startButton.textContent = 'D√©marrer une nouvelle course !';
            statusText.textContent = 'Course Termin√©e';
        }, 1500);
    }

    // --- Initialization ---

    // Initialize the canvas size and draw the initial state on load
    window.onload = function() {
        resizeCanvas();
        drawTrack();
        initializeFirebase();
    }
</script>

</body>
</html>



