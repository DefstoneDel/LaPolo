<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>La Polo du Myth - Simulateur de Crash et High Score</title>
    <!-- Chargement de Tailwind CSS pour les classes utilitaires -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- STYLES CSS INT√âGR√âS (contenu de style.css) -->
    <style>
        /* Custom CSS for a racing game feel */
        @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@600;700&display=swap');
        
        body {
            background-color: #1a1a2e; /* Deep purple background */
            color: #ffffff;
            font-family: 'Chakra Petch', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            width: 100%;
            max-width: 768px;
            background-color: #0f0f1c; /* Darker inner panel */
            border: 4px solid #e94560; /* Racing red border */
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(233, 69, 96, 0.4);
            text-align: center;
        }

        canvas {
            display: block;
            width: 100%; 
            height: auto;
            max-height: 400px;
            background-color: #272744; 
            border-radius: 10px;
            margin: 20px auto;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
        }

        /* Button Styles */
        #start-button, .action-button, .auth-button, .select-input {
            transition: all 0.2s ease-in-out;
            font-weight: 700;
            padding: 12px 30px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
        }
        
        #start-button {
            background-color: #53bf9d; /* Teal/Green for GO */
            color: #1a1a2e;
            font-size: 1.25rem;
            box-shadow: 0 4px #429a7e;
        }
        #start-button:hover:not(:disabled) {
            background-color: #63d1ac;
            transform: translateY(-2px);
            box-shadow: 0 6px #429a7e;
        }
        #start-button:active:not(:disabled) {
            transform: translateY(2px);
            box-shadow: 0 2px #429a7e;
        }

        .action-button {
            background-color: #4a5568; /* Gray for actions */
            color: #ffffff;
            box-shadow: 0 3px #3c4452;
        }

        .auth-button { /* Kept for styling, but less used */
            background-color: #e94560; /* Red for auth */
            color: #ffffff;
            box-shadow: 0 3px #cc3a52;
        }

        .disabled-button {
            opacity: 0.6;
            cursor: not-allowed;
            background-color: #aaaaaa !important;
            box-shadow: 0 4px #777777 !important;
        }

        .result-text {
            min-height: 60px;
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #0f0f1c;
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 10px 30px rgba(233, 69, 96, 0.6);
        }

        /* Select Input Styling */
        .select-input {
            appearance: none; /* Remove default browser styling */
            background-color: #4a5568; /* Match action button */
            color: #ffffff;
            font-size: 1rem;
            text-align: center;
            line-height: 1.5;
            min-width: 150px;
            height: 48px; /* Match button height */
            box-shadow: 0 3px #3c4452;
            cursor: pointer;
            outline: none;
            border: 1px solid #3c4452;
        }
        .select-input:hover {
            background-color: #5a667b;
        }
        .select-input option {
            background-color: #0f0f1c; /* Dark background for options */
            color: #ffffff;
        }


        /* Responsive adjustments for mobile devices (< 640px) */
        @media (max-width: 640px) {
            .container {
                padding: 20px 10px; 
                margin: 10px; 
                border-width: 2px; 
            }
            #start-button, .action-button, .auth-button, .select-input {
                font-size: 1rem;
                padding: 10px 20px;
                width: 100%; /* Make select full width on small screens */
            }
        }
    </style>
</head>
<body>

<div class="container">
    <div class="flex justify-between items-center mb-6">
        <div id="auth-status" class="text-sm font-medium text-gray-400 text-left flex items-center">
            <span>Chargement...</span>
            <button id="edit-username-button" class="ml-2 text-pink-400 hover:text-pink-300 text-xs font-bold py-1 px-2 rounded-md border border-pink-400 hidden" onclick="showEditUsernameModal()">Modifier</button>
        </div>
        <div>
            <!-- No auth toggle anymore -->
        </div>
    </div>
    
    <h1 class="text-3xl font-bold mb-2 text-pink-400">La Polo du Myth</h1>
    <div id="high-score" class="text-xl font-extrabold mb-4 text-yellow-300">
        Plus Grande Distance: 0m (Temps au tour: N/A)
    </div>
    <p class="mb-6 text-gray-300">Myth survivra-t-il dans sa Polo ? La course continue jusqu'√† ce qu'il s'√©crase !</p>

    <!-- Beer Selection and current game parameters display -->
    <div class="flex flex-col md:flex-row justify-center items-center gap-4 mb-6">
        <label for="beer-select" class="text-lg font-semibold text-gray-300">Bi√®res bues:</label>
        <select id="beer-select" class="select-input" onchange="handleBeerSelection(this.value)">
            <option value="0">0 Bi√®re</option>
            <option value="1">1 Bi√®re</option>
            <option value="2">2 Bi√®res</option>
            <option value="3">3 Bi√®res</option>
            <option value="4">4 Bi√®res</option>
            <option value="5">5 Bi√®res</option>
        </select>
    </div>
    <div id="game-stats" class="mb-6 text-gray-400 text-sm">
        <p>Chance de Crash: <span id="current-crash-chance">20.00%</span></p>
        <p>Temps au tour estim√©: <span id="estimated-lap-time">4.000s</span></p>
    </div>
    <!-- END NEW -->

    <div class="flex flex-col md:flex-row justify-center items-center gap-4 mb-6">
        <button id="start-button" onclick="runSimulation()">
            D√©marrer la Course !
        </button>
        <p id="current-status" class="text-xl font-semibold text-yellow-300">Pr√™t</p>
    </div>

    <canvas id="race-track" width="600" height="300"></canvas>
    
    <div id="results" class="result-text mt-6 text-2xl font-extrabold">
        <!-- Les r√©sultats seront affich√©s ici -->
    </div>

    <!-- SECTION CLASSEMENT GLOBAL -->
    <div class="mt-8">
        <h2 class="text-2xl font-bold mb-4 text-yellow-400">üèÜ Top Mythes</h2>
        <div id="leaderboard" class="bg-gray-800 p-4 rounded-lg shadow-inner">
            <p class="text-gray-400">Chargement du classement...</p>
        </div>
    </div>
</div>

<div id="edit-username-modal" class="modal">
    <div class="modal-content">
        <h2 class="text-2xl font-bold mb-4 text-pink-400">Choisir un Nom d'Utilisateur</h2>
        <form id="username-form" onsubmit="handleUsernameEditSubmit(event)">
            <input type="text" id="new-username-input" placeholder="Votre Nom d'Utilisateur" required minlength="3" maxlength="20"
                   class="w-full p-3 mb-3 bg-gray-700 text-white border border-gray-600 rounded-lg focus:ring-pink-500 focus:border-pink-500">
            <p id="username-error" class="text-red-400 mb-4 h-6"></p>
            <button type="submit" class="action-button w-full mb-3">
                Sauvegarder
            </button>
            <button type="button" class="auth-button w-full" onclick="document.getElementById('edit-username-modal').style.display='none'">
                Annuler
            </button>
        </form>
    </div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged, updateProfile } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, setDoc, getDoc, collection, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- Firebase Setup (MANDATORY) ---
    // ‚ö†Ô∏è ATTENTION : SI VOUS EX√âCUTEZ CE CODE HORS DU CANVAS (ex: sur GitHub), 
    // VEUILLEZ REMPLACER LES CHA√éNES VIDES ("") CI-DESSOUS PAR VOTRE CONFIGURATION FIREBASE R√âELLE 
    // POUR ACTIVER LA SAUVEGARDE ET LE CLASSEMENT GLOBAL.

    // 1. D√âFINISSEZ VOTRE CONFIGURATION ICI :
    const GITHUB_FIREBASE_CONFIG = {
        apiKey: "AIzaSyBsWugLEz2bu5xjbR5VtYXMr7cUhD6ycEE", // CL√â REQUISE pour la sauvegarde
        authDomain: "lapolo-5351b.firebaseapp.com",
        projectId: "lapolo-5351b", 
        storageBucket: "lapolo-5351b.firebasestorage.app",
        messagingSenderId: "1031146720807",
        appId: "1:1031146720807:web:6324e1b371bbb953410802"
    };
    const GITHUB_APP_ID = GITHUB_FIREBASE_CONFIG.projectId || 'local-github-app';


    // 2. LOGIQUE DE S√âLECTION DE LA CONFIGURATION :
    const isCanvas = typeof __app_id !== 'undefined';
    
    const appId = isCanvas 
        ? __app_id 
        : GITHUB_APP_ID;
    const firebaseConfig = isCanvas 
        ? JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}')
        : GITHUB_FIREBASE_CONFIG;
    const initialAuthToken = null; 
    
    const isGithubPlaceholder = !isCanvas && (!firebaseConfig.apiKey || firebaseConfig.apiKey === "YOUR_API_KEY_GOES_HERE");
    
    // --------------------------------------------------------------------------------


    let app;
    let db;
    let auth;
    let userId = null;
    let currentHighestDistanceMeters = 0; // MODIFIED: Renamed from currentHighScore
    let currentFastestLapTime = Infinity; 
    let currentUsername = null; 
    
    // Game constants for new mechanics
    const METERS_PER_LAP = 100; // 1 lap equals 100 meters
    const BASE_CRASH_CHANCE = 0.20; // 20% crash chance with 0 beers
    const BEER_EFFECT_PER_BEER = 0.07; // 7% increase in crash chance AND speed per beer
    const BASE_LAP_TIME_SECONDS = 4.0; // 4 seconds per lap with 0 beers

    // Game variables - now dynamically adjusted
    let selectedBeers = 0; 
    let currentCrashChance = BASE_CRASH_CHANCE; 
    let currentEffectiveLapTimeSeconds = BASE_LAP_TIME_SECONDS; 

    let isRacing = false;
    let lapCount = 0; // Still useful for full laps
    let totalDistanceMeters = 0; // NEW: Cumulative distance in current simulation
    let lastCheckedDistanceMarker = 0; // NEW: To track crash check points (0m, 50m, 100m within current lap)

    let angle = 0; 
    let anglePerFrame = 0.0; 
    let animationFrameId;

    let lapStartTime = 0; 
    let simulationFastestLapTime = Infinity; 

    // Canvas variables
    const canvas = document.getElementById('race-track');
    const ctx = canvas.getContext('2d');
    const statusText = document.getElementById('current-status');
    const resultsDiv = document.getElementById('results');
    const startButton = document.getElementById('start-button');
    const authStatusDiv = document.getElementById('auth-status');
    const highScoreDiv = document.getElementById('high-score');
    const leaderboardDiv = document.getElementById('leaderboard'); 
    const editUsernameButton = document.getElementById('edit-username-button'); 

    // UI elements for game parameters
    const beerSelect = document.getElementById('beer-select');
    const currentCrashChanceSpan = document.getElementById('current-crash-chance');
    const estimatedLapTimeSpan = document.getElementById('estimated-lap-time');


    let centerX, centerY, radiusX, radiusY;

    const editUsernameModal = document.getElementById('edit-username-modal');
    const newUsernameInput = document.getElementById('new-username-input');
    const usernameError = document.getElementById('username-error');

    // --- Function to update game parameters based on beer selection ---
    function updateGameParameters() {
        selectedBeers = parseInt(beerSelect.value);

        // Calculate current crash chance
        currentCrashChance = BASE_CRASH_CHANCE + (selectedBeers * BEER_EFFECT_PER_BEER);
        currentCrashChance = Math.max(0, Math.min(1.0, currentCrashChance)); // Cap between 0 and 1
        currentCrashChanceSpan.textContent = `${(currentCrashChance * 100).toFixed(2)}%`;

        // Calculate effective lap time (speed increase means lower time)
        const speedModifier = (selectedBeers * BEER_EFFECT_PER_BEER);
        currentEffectiveLapTimeSeconds = BASE_LAP_TIME_SECONDS * (1 - speedModifier);
        currentEffectiveLapTimeSeconds = Math.max(3.0, currentEffectiveLapTimeSeconds); // Ensure minimum 3.0s lap
        estimatedLapTimeSpan.textContent = `${currentEffectiveLapTimeSeconds.toFixed(3)}s`;

        // Recalculate anglePerFrame based on the new effective lap time
        // 60 frames per second is standard for requestAnimationFrame
        anglePerFrame = (2 * Math.PI) / (currentEffectiveLapTimeSeconds * 60);

        console.log(`Beers: ${selectedBeers}, Crash Chance: ${currentCrashChance.toFixed(2)}, Effective Lap Time: ${currentEffectiveLapTimeSeconds.toFixed(3)}s, Angle per frame: ${anglePerFrame.toFixed(5)}`);
    }

    // Event handler for beer selection dropdown
    window.handleBeerSelection = (value) => {
        updateGameParameters();
    };


    // --- Firestore High Score Management (Private Data) ---

    function getHighScoreDocRef() {
        if (!db || !userId) return null;
        return doc(db, 'artifacts', appId, 'users', userId, 'game_data', 'high_score');
    }

    async function fetchHighScore() {
        if (isGithubPlaceholder || !userId || !db) return;
        try {
            const docRef = getHighScoreDocRef();
            const docSnap = await getDoc(docRef);

            if (docSnap.exists()) {
                const data = docSnap.data();
                currentHighestDistanceMeters = data.maxDistanceMeters || 0; // MODIFIED field name
                currentFastestLapTime = data.fastestLapTime || Infinity;
            } else {
                currentHighestDistanceMeters = 0;
                currentFastestLapTime = Infinity;
            }
            updateHighScoreDisplay(); 
        } catch (error) {
            console.error("Erreur lors de la r√©cup√©ration du score:", error);
            currentHighestDistanceMeters = 0;
            currentFastestLapTime = Infinity;
            updateHighScoreDisplay();
        }
    }

    // Function to update the personal high score text
    function updateHighScoreDisplay() {
        let distanceText = `Plus Grande Distance: ${currentHighestDistanceMeters.toFixed(0)}m`;
        let timeText = `Temps au tour: ${currentFastestLapTime === Infinity ? 'N/A' : currentFastestLapTime.toFixed(3) + 's'}`;
        highScoreDiv.textContent = `${distanceText} (${timeText})`;
    }


    async function updateHighScore(newDistance, newFastestTime) { // MODIFIED: newDistance instead of newScore (laps)
        if (isGithubPlaceholder || !userId || !db) {
             console.warn("Sauvegarde des scores ignor√©e : Firebase non configur√© ou mode local.");
             currentHighestDistanceMeters = Math.max(currentHighestDistanceMeters, newDistance);
             currentFastestLapTime = Math.min(currentFastestLapTime, newFastestTime);
             updateHighScoreDisplay(); 
             return;
        }
        
        // Logic to update: higher distance OR same distance with better time
        if (newDistance > currentHighestDistanceMeters || (newDistance === currentHighestDistanceMeters && newFastestTime < currentFastestLapTime)) {
            try {
                const docRef = getHighScoreDocRef();
                await setDoc(docRef, { 
                    maxDistanceMeters: newDistance, // MODIFIED field name
                    fastestLapTime: newFastestTime 
                }, { merge: true });
                
                currentHighestDistanceMeters = newDistance;
                currentFastestLapTime = newFastestTime;
                updateHighScoreDisplay(); 
                console.log("Meilleur score mis √† jour:", newDistance.toFixed(0), "m, Fastest Lap Time:", newFastestTime.toFixed(3));

                if (auth.currentUser && currentUsername) {
                     updateGlobalScore(newDistance, newFastestTime, currentUsername);
                }

            } catch (error) {
                console.error("Erreur lors de la mise √† jour du score:", error);
            }
        }
    }

    // --- Global Leaderboard Management (Public Data) ---

    async function updateGlobalScore(newDistance, newFastestTime, username) { // MODIFIED: newDistance
        if (isGithubPlaceholder || !db || !auth.currentUser || !username) return; 

        try {
            const globalDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'global_high_scores', auth.currentUser.uid);
            
            const docSnap = await getDoc(globalDocRef);
            let existingGlobalMaxDistanceMeters = 0; // MODIFIED field name
            let existingGlobalFastestTime = Infinity;

            if (docSnap.exists()) {
                const data = docSnap.data();
                existingGlobalMaxDistanceMeters = data.maxDistanceMeters || 0; // MODIFIED field name
                existingGlobalFastestTime = data.fastestLapTime || Infinity;
            }

            // Logic to update global entry: higher distance OR same distance with better time
            if (newDistance > existingGlobalMaxDistanceMeters || (newDistance === existingGlobalMaxDistanceMeters && newFastestTime < existingGlobalFastestTime)) {
                await setDoc(globalDocRef, {
                    userId: auth.currentUser.uid,
                    username: username,
                    maxDistanceMeters: newDistance, // MODIFIED field name
                    fastestLapTime: newFastestTime, 
                    updatedAt: new Date().toISOString()
                });
                console.log("Score global mis √† jour:", newDistance.toFixed(0), "m, Fastest Lap Time:", newFastestTime.toFixed(3));
                fetchGlobalLeaderboard(); 
            }

        } catch (error) {
            console.error("Erreur lors de la mise √† jour du score global:", error);
        }
    }
    
    async function fetchGlobalLeaderboard() {
        if (isGithubPlaceholder || !db) {
            leaderboardDiv.innerHTML = '<p class="text-yellow-500">Le classement est d√©sactiv√©. Configurez Firebase pour le voir.</p>';
            return;
        }

        try {
            const leaderboardCollectionRef = collection(db, 'artifacts', appId, 'public', 'data', 'global_high_scores');
            
            // MODIFIED: Order by maxDistanceMeters DESC, then fastestLapTime ASC
            // IMPORTANT: This query will require a composite index in your Firebase console:
            // Collection: global_high_scores, Fields: maxDistanceMeters (Descending), fastestLapTime (Ascending)
            const q = query(leaderboardCollectionRef, orderBy('maxDistanceMeters', 'desc'), orderBy('fastestLapTime', 'asc'), limit(10));
            const querySnapshot = await getDocs(q);

            let html = '';
            if (querySnapshot.empty) {
                html = '<p class="text-gray-400">Aucun score enregistr√©. Soyez le premier !</p>';
            } else {
                for (let i = 0; i < querySnapshot.docs.length; i++) {
                    const docSnap = querySnapshot.docs[i];
                    const data = docSnap.data();
                    
                    const rank = i + 1;

                    console.log(`DEBUG: Leaderboard entry - loop index: ${i}, calculated rank: ${rank}, username: ${data.username || 'Unknown'}, distance: ${data.maxDistanceMeters}, fastestTime: ${data.fastestLapTime}`);

                    let displayRankString;
                    let medalColorClass;

                    if (rank === 1) {
                        displayRankString = 'ü•á #1';
                        medalColorClass = 'text-yellow-300';
                    } else if (rank === 2) {
                        displayRankString = 'ü•à #2';
                        medalColorClass = 'text-gray-300';
                    } else if (rank === 3) {
                        displayRankString = 'ü•â #3';
                        medalColorClass = 'text-amber-500';
                    } else {
                        displayRankString = `#${rank}`;
                        medalColorClass = 'text-gray-400';
                    }
                    
                    const highlightClass = (data.userId === userId && auth.currentUser) ? 'bg-pink-800/50' : 'hover:bg-gray-700/50';
                    
                    const fastestTimeDisplay = data.fastestLapTime === Infinity || data.fastestLapTime === undefined ? 'N/A' : data.fastestLapTime.toFixed(3) + 's';
                    // MODIFIED: Display maxDistanceMeters
                    const distanceDisplay = data.maxDistanceMeters === undefined ? '0' : data.maxDistanceMeters.toFixed(0);

                    html += `
                        <div class="flex justify-between items-center p-3 my-1 rounded-lg ${highlightClass}">
                            <span class="text-xl font-extrabold ${medalColorClass}">${displayRankString}</span>
                            <span class="text-lg font-semibold">${data.username || 'Utilisateur inconnu'}</span>
                            <span class="text-lg font-bold text-teal-400">${distanceDisplay}m <span class="text-gray-400 text-base">(${fastestTimeDisplay})</span></span>
                        </div>
                    `;
                }
            }
            leaderboardDiv.innerHTML = html;

        } catch (error) {
            console.error("Erreur lors de la r√©cup√©ration du classement:", error);
            leaderboardDiv.innerHTML = '<p class="text-red-400">Erreur lors du chargement du classement.</p>';
        }
    }


    // --- Firestore Profile Management ---

    async function fetchUserProfile(uid) {
        if (isGithubPlaceholder || !db) return null;
        try {
            const profileDocRef = doc(db, 'artifacts', appId, 'users', uid, 'profile', 'data');
            const docSnap = await getDoc(profileDocRef);
            return docSnap.exists() ? docSnap.data().username : null;
        } catch (error) {
            console.error("Erreur lors de la r√©cup√©ration du profil:", error);
            return null;
        }
    }

    async function saveUserProfile(uid, username) {
        if (isGithubPlaceholder || !db) return;
        try {
            const profileDocRef = doc(db, 'artifacts', appId, 'users', uid, 'profile', 'data');
            await setDoc(profileDocRef, { username: username, createdAt: new Date().toISOString() }, { merge: true });
        } catch (error) {
            console.error("Erreur lors de la sauvegarde du profil:", error);
        }
    }


    // --- Authentication Logic ---

    function updateAuthUI(user) {
        if (isGithubPlaceholder) {
            authStatusDiv.querySelector('span').textContent = 'Mode Local (Scores non sauvegard√©s).';
            editUsernameButton.style.display = 'none';
            updateHighScoreDisplay(); 
            return;
        }

        if (user) {
            userId = user.uid;
            
            fetchUserProfile(user.uid).then(username => {
                currentUsername = username;
                
                authStatusDiv.querySelector('span').innerHTML = `Connect√© comme : <span class="text-pink-400">${username || 'Anonyme'}</span>`;
                editUsernameButton.style.display = 'inline-block';
            });
            
            fetchHighScore(); 
            fetchGlobalLeaderboard(); 
        } else {
            userId = null;
            currentUsername = null;
            currentHighestDistanceMeters = 0; // Reset highest distance
            currentFastestLapTime = Infinity; 
            authStatusDiv.querySelector('span').textContent = 'Non connect√©. Connectez-vous pour sauvegarder votre score.';
            updateHighScoreDisplay(); 
            editUsernameButton.style.display = 'none';
        }
    }

    async function initializeFirebase() {
        if (isGithubPlaceholder) {
            console.warn("‚ö†Ô∏è Mode GitHub sans configuration Firebase : La sauvegarde des scores et l'authentification sont d√©sactiv√©es.");
            updateAuthUI(null); 
            return;
        }
        
        if (Object.keys(firebaseConfig).length === 0 || !firebaseConfig.apiKey) {
            console.error("Erreur: Configuration Firebase incompl√®te.");
            authStatusDiv.querySelector('span').textContent = 'ERREUR FIREBASE. Configuration manquante. V√©rifiez la console.';
            return;
        }

        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app); 

            onAuthStateChanged(auth, async (user) => {
                if (!user) {
                    await signInAnonymously(auth);
                } else {
                    updateAuthUI(user);
                }
            });

            if (!auth.currentUser) {
                 await signInAnonymously(auth);
            }
            
            updateGameParameters();

        } catch (error) {
            console.error("Erreur fatale lors de l'initialisation de Firebase:", error);
            authStatusDiv.querySelector('span').textContent = 'ERREUR FIREBASE FATALE. V√©rifiez la console et votre configuration.';
            db = null;
            auth = null;
        }
    }

    window.showEditUsernameModal = () => {
        if (isGithubPlaceholder || !auth.currentUser) return;
        newUsernameInput.value = currentUsername || '';
        usernameError.textContent = '';
        editUsernameModal.style.display = 'flex';
    };

    window.handleUsernameEditSubmit = async (event) => {
        event.preventDefault();
        const newUsername = newUsernameInput.value.trim();
        usernameError.textContent = '';

        if (!newUsername || newUsername.length < 3 || newUsername.length > 20) {
            usernameError.textContent = 'Le nom d\'utilisateur doit contenir entre 3 et 20 caract√®res.';
            return;
        }
        if (newUsername === currentUsername) {
            editUsernameModal.style.display = 'none';
            return;
        }

        try {
            if (auth.currentUser && auth.currentUser.uid) {
                await saveUserProfile(auth.currentUser.uid, newUsername);
                currentUsername = newUsername;
                updateAuthUI(auth.currentUser);
                fetchGlobalLeaderboard();
                editUsernameModal.style.display = 'none';
                console.log("Nom d'utilisateur mis √† jour:", newUsername);
            }
        } catch (error) {
            console.error("Erreur lors de la mise √† jour du nom d'utilisateur:", error);
            usernameError.textContent = 'Erreur lors de la sauvegarde du nom. Veuillez r√©essayer.';
        }
    };


    // --- Drawing Functions ---

    function resizeCanvas() {
        const parent = canvas.parentElement;
        const desiredWidth = parent.clientWidth;
        const desiredHeight = desiredWidth / 2; 

        canvas.width = desiredWidth > 600 ? 600 : desiredWidth;
        canvas.height = desiredHeight > 300 ? 300 : desiredHeight;

        centerX = canvas.width / 2;
        centerY = canvas.height / 2;
        radiusX = centerX * 0.7; 
        radiusY = centerY * 0.7; 
        
        if (!isRacing) {
            drawTrack(false);
        }
    }

    window.addEventListener('resize', resizeCanvas);

    function drawTrack(isCrashed = false) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 1. Draw Racing Green Grass (infield)
        ctx.fillStyle = '#272744';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 2. Draw Outer Track Boundary (White Line)
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 15;
        ctx.ellipse(centerX, centerY, radiusX + 15, radiusY + 15, 0, 0, 2 * Math.PI);
        ctx.stroke();

        // 3. Draw Track Surface (Asphalt)
        ctx.beginPath();
        ctx.fillStyle = '#3c4048'; // Dark asphalt gray
        ctx.ellipse(centerX, centerY, radiusX + 5, radiusY + 5, 0, 0, 2 * Math.PI);
        ctx.fill();

        // 4. Draw Inner Track Boundary (White Line)
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 10;
        
        const innerRadiusX = Math.max(1, radiusX - 10);
        const innerRadiusY = Math.max(1, radiusY - 10);
        
        ctx.ellipse(centerX, centerY, innerRadiusX, innerRadiusY, 0, 0, 2 * Math.PI);
        ctx.stroke();

        // 5. Draw Start/Finish Line (Red/White stripes)
        const startX = centerX + radiusX;
        const startY = centerY;
        
        ctx.lineWidth = 5;
        ctx.strokeStyle = 'white';
        ctx.beginPath();
        ctx.moveTo(startX, startY - 15);
        ctx.lineTo(startX, startY + 15);
        ctx.stroke();
        
        ctx.strokeStyle = '#e94560'; // Red
        ctx.beginPath();
        ctx.moveTo(startX, startY - 10);
        ctx.lineTo(startX, startY + 10);
        ctx.stroke();

        // 6. Draw Car
        let currentAngle = angle;
        
        // Calculate car position on the ellipse
        const carX = centerX + radiusX * Math.cos(currentAngle);
        const carY = centerY + radiusY * Math.sin(currentAngle);

        // Calculate car rotation (tangent to the ellipse path)
        const dx = -radiusX * Math.sin(currentAngle);
        const dy = radiusY * Math.cos(currentAngle);
        const rotation = Math.atan2(dy, dx);

        ctx.save();
        ctx.translate(carX, carY);
        ctx.rotate(rotation);

        if (isCrashed) {
            // Apply crash transformation
            const crashJitterX = Math.random() * 8 - 4;
            const crashJitterY = Math.random() * 8 - 4;
            ctx.rotate(Math.PI / 8); 
            ctx.translate(crashJitterX, crashJitterY);
        }

        // Car Body (The "Polo") - Set to Dark Green or Red if crashed
        ctx.fillStyle = isCrashed ? '#ff0000' : '#1e4620';
        ctx.fillRect(-15, -8, 30, 16);
        
        // Cabin
        ctx.fillStyle = '#222222';
        ctx.fillRect(-5, -6, 10, 8); 

        // Headlights (only if not crashed)
        if (!isCrashed) {
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(12, -6, 3, 2);
            ctx.fillRect(12, 4, 3, 2);
        }

        // Wheels
        ctx.fillStyle = '#333333';
        ctx.beginPath();
        ctx.arc(-10, -8, 4, 0, 2 * Math.PI); ctx.fill();
        ctx.beginPath();
        ctx.arc(-10, 8, 4, 0, 2 * Math.PI); ctx.fill();
        ctx.beginPath();
        ctx.arc(10, -8, 4, 0, 2 * Math.PI); ctx.fill();
        ctx.beginPath();
        ctx.arc(10, 8, 4, 0, 2 * Math.PI); ctx.fill();

        ctx.restore();

        // Draw Crash Smoke/Particles if crashed
        if (isCrashed) {
            for(let i = 0; i < 20; i++) {
                const smokeX = carX + (Math.random() - 0.5) * 40;
                const smokeY = carY + (Math.random() - 0.5) * 40;
                const smokeRadius = Math.random() * 10 + 5;
                ctx.fillStyle = `rgba(150, 150, 150, ${Math.random() * 0.6})`;
                ctx.beginPath();
                ctx.arc(smokeX, smokeY, smokeRadius, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
    }

    // --- Simulation Core Logic ---

    function gameLoop(timestamp) {
        if (!isRacing) {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            return;
        }

        const prevAngle = angle;
        angle += anglePerFrame;

        // Calculate current progress within the current lap in meters
        const currentLapProgressRadians = angle % (2 * Math.PI);
        const metersIntoCurrentLap = (currentLapProgressRadians / (2 * Math.PI)) * METERS_PER_LAP;

        const prevTotalDistanceMeters = totalDistanceMeters; 
        totalDistanceMeters = (lapCount * METERS_PER_LAP) + metersIntoCurrentLap;

        // Check for crash at 50m intervals (including end of lap)
        // We only check if we *crossed* a specific 50m/100m threshold in this frame
        for (let checkPoint = 50; checkPoint <= METERS_PER_LAP; checkPoint += 50) {
            const thresholdDistanceInLap = checkPoint;
            
            // Calculate the absolute distance for this checkpoint in the current lap
            const absoluteThresholdDistance = (lapCount * METERS_PER_LAP) + thresholdDistanceInLap;
            
            // Check if we just crossed this threshold AND haven't checked for this specific checkpoint in this lap yet
            if (totalDistanceMeters >= absoluteThresholdDistance && prevTotalDistanceMeters < absoluteThresholdDistance) {
                console.log(`Checking crash at ${absoluteThresholdDistance.toFixed(2)}m (threshold: ${thresholdDistanceInLap}m into lap)`);
                if (Math.random() < currentCrashChance) {
                    console.log(`Crash occurred at ${totalDistanceMeters.toFixed(2)}m!`);
                    endSimulation(true); 
                    return; 
                }
            }
        }

        // Check for lap completion (now mainly for lapCount and recording fastest lap time)
        const currentLapCeilingRadians = (lapCount + 1) * (2 * Math.PI);
        if (angle >= currentLapCeilingRadians && prevAngle < currentLapCeilingRadians) {
            const lapElapsedTime = (performance.now() - lapStartTime) / 1000;
            simulationFastestLapTime = Math.min(simulationFastestLapTime, lapElapsedTime);

            lapCount++;
            lapStartTime = performance.now(); // Reset lap start time for the next lap
        }

        statusText.textContent = `Distance: ${totalDistanceMeters.toFixed(2)}m`; 
        drawTrack();
        animationFrameId = requestAnimationFrame(gameLoop);
    };

    window.runSimulation = () => {
        if (isRacing) return;

        if (!userId) { 
            resultsDiv.classList.add('text-red-400');
            resultsDiv.innerHTML = `‚ö†Ô∏è Veuillez patienter, l'application est en cours d'initialisation...`;
            return;
        }

        // Disable beer selection during race
        beerSelect.disabled = true;
        beerSelect.classList.add('disabled-button');

        // 1. Reset State for new simulation
        isRacing = true;
        lapCount = 0;
        totalDistanceMeters = 0; // Reset total distance
        lastCheckedDistanceMarker = 0; // Reset crash check marker
        angle = 0;
        resultsDiv.innerHTML = '';
        simulationFastestLapTime = Infinity; // Reset fastest lap for this simulation
        
        // 2. Update UI
        startButton.disabled = true;
        startButton.classList.add('disabled-button');
        startButton.textContent = 'COURSE EN COURS...';
        statusText.textContent = `Distance: 0.00m`; 

        // Set initial lap start time
        lapStartTime = performance.now();

        // 3. Start Loop
        animationFrameId = requestAnimationFrame(gameLoop);
    };

    function endSimulation(crashed) {
        isRacing = false;
        
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }

        if (crashed) {
            drawTrack(true); 
            resultsDiv.classList.remove('text-green-400');
            resultsDiv.classList.add('text-red-400');
            resultsDiv.innerHTML = `üö® **CRASH !** Myth s'est √©cras√© apr√®s ${totalDistanceMeters.toFixed(2)}m ! üíî<br><span>Meilleur temps au tour de la simulation: ${simulationFastestLapTime === Infinity ? 'N/A' : simulationFastestLapTime.toFixed(3) + 's'}</span>`;

            updateHighScore(totalDistanceMeters, simulationFastestLapTime); 
        } 
        
        setTimeout(() => {
            beerSelect.disabled = false;
            beerSelect.classList.remove('disabled-button');
            startButton.disabled = false;
            startButton.classList.remove('disabled-button');
            startButton.textContent = 'D√©marrer une nouvelle course !';
            statusText.textContent = 'Course Termin√©e';
        }, 1500);
    }

    // --- Initialization ---

    window.onload = function() {
        resizeCanvas();
        drawTrack();
        initializeFirebase();
    }
</script>

</body>
</html>



